function myBind(obj, fname) {
  var f = function() {
		return obj[fname]()
	}
	return f
   
}

Задачи по JavaScript
Каждую задачу нужно оформить в отдельном файле 1.js, 2.js и т.д.
Название функций и порядок аргументов менять нельзя (не сработают автотесты)
Примеры в задачах – это лишь примеры, в автотестах кроме этих будут и другие аналогичные, по этому во время проверки используйте несколько вариантов
Обратите внимание на граничные случаи в задаче №2, на все случаи в примерах №6, и на порядок аргументов в №7
Советую использовать какой нибудь фреймворк для юнит тестов (mocha + chai https://mochajs.org/#getting-started), гораздо облегчит написание этих функций
Если вам не понятно условие - пишите
Ответ необходимо прислать мне Vadim.Suschenko@miratechgroup.com и HR в течении суток с момента получения задания.


#1
Написать функцию bindAll(obj) которая получает на вход объект вида
var complexNum = { r: 1, i: 2, mod: function() { return Math.sqrt(this.r * this.r + this.i * this.i); } };
И переделывает все его методы таким образом что код:
var mod= complexNum.mod;
mod() === complexNum.mod() вернет истину (то есть mod будет работать одинаково в обоих случаях)

#2
Напишите функцию deepEqual(val1, val2) которая производит “глубокое” сравнение двух значений, и возвращает результат сравнения (true или false). val1 и val2 могут быть любого типа (булевы значения, числа, строки, массивы, объекты, функции) эквивалентность функций означает что код этих функций - одинаковый.

#3
Написать код, после выполнения которого, возможны след. операции:
[1, 2, 3].toList() которая превращает массив любых значений в структуру след вида
var list = {
	head: 1,
	tail: {
		head: 2,
		tail: {


			head: 3,
			tail: undefined
		}
	}
}
list.toArray() которая делает обратную операцию => [1, 2, 3]
list.nth(n_elem)  возвращает значение n-го элемента от начала списка (нумерация начиная с 0).

#4
Написать функцию seq которая на вход получает пользовательскую функцию f, а на выходе возвращает функцию, вызывая ее, каждый раз можно получить последовательность чисел, определяемую пользовательской функцией f. Функция f принимает на вход в качестве аргументов результаты всех своих предыдущих вызовов. Порядок аргументов такой: слева находится результат предыдущего вызова, потом результат пред-предыдущего и т.д. Например, для генерации чисел Фибоначчи можно использовать след код:
var fib = seq(function(n1, n2) { return (n1 + n2) || 1; });
fib() => 1
fib() => 1
fib() => 2
fib() => 3
fib() => 5 и т.д.

#5
Написать функцию logIt(obj) на вход которой поступает объект вида (пример)
var complexNum = { r: 1, i: 2, mod: function() { return Math.sqrt(this.r * this.r + this.i * this.i); }, add: function(r, i) { this.r += r; this.i += i; } };
Функция модифицирует его таким образом, что потом, при вызове каждого метода, происходит распечатка в консоли браузера имени вызванного метода и его аргументов.
Предположим есть составной объект:
var obj = {
	x: 6,
	inner: {
		a: ‘test’,
		b: [1, 2, 3]
	}
}

#6
Написать функцию extract(obj, strPath) которая извлекает данные из такого объекта по пути:
extract(obj, ‘x’) => 6
extract(obj, ‘inner.a’) => ‘test’
extract(obj, ‘inner.b[2]’) => 3
extract(obj, ‘inner[‘b’][2]’) => 3 (доступ к свойству объекта через [ ])
PS: eval использовать нельзя! (решение в этом случае - 1 строка)

#7
Написать функцию curry которая на вход принимает функцию f с n аргументами (n >= 1) и возвращает функцию g с 1 аргументом. Причем, первоначальный вызов f с n аргументами можно выполнить путем n вызовов g c 1 аргументом. например:
function add3(a, b, c) { return a + b + c; }
var g = curry(add3);
g(1); g(2); g(3) => третий вызов вернет 6
добавить возможность “сцепления”
g(1)(2)(3); => 6


***************************************************
Напишите класс Chessboard, абстракция шахматной доски с фигурами. Написать класс Horse (конь), 
с признаком черный или белый. На шахматной доске возможно размещение произвольного количества черных и белых коней 
(лишь бы хватило клеток). В одной клетке не может быть размещено более одного коня. у класса Horse 
должно быть свойство, для получения списка возможных ходов конкретного коня, 
с учетом занятых фигур и списком вражеских коней, которых, конкретный конь может побить.  

Напишите класс Point (точка на экране) класс Rectangle (прямоугольник на экране со сторонами параллельными границам экрана). 
Написать метод класса  Rectangle.inRect который возвращает истина если точка лежит внутри прямоугольника и ложь в 
обратном случае. если точка попадает на верхнюю или левую границу прямоугольника - считается что он 
принадлежит прямоугольнику иначе не принадлежит. Написать метод Rectangle.intersect(otherRect) - 
пересечение двух прямоугольников - возвращается прямоугольник который принадлежит одновременно обоим прямоугольникам, 
Написать метод Rectangle.union(otherRect) возвращается наименьший прямоугольник содержащий оба прямоугольника. 
Предусмотреть возможность существования пустого прямоугольника, который может образоваться 
в методе Intersect (добавить свойство Rectangle.IsEmpty). Реализовать метод Rectangle.move(newPoint), перемещает прямоугольник 
(без изменения размеров в точку newPoint (левый верхний угол совмещается с newPoint). Добавить свойство Rectangle.center.

Реализовать игру крестики-нолики. Первым ходит человек, используя функцию prompt (с номером клетки), 
а вывод осуществляется через консоль или document.write - для простоты (если есть желание, можно, 
использовать HTML таблицу + обработчики кликов как игровое поле).

Создать класс World для симуляции живого мира. В мире могут быть существа 3х типов: растения, травоядные и хищники. Мир представляет собой массив 50 на 50 клеток (можно сделать замкнутым - то есть при переходе через границу 50 соответствующая координата становиться 0). у каждой сущности есть координаты и свойство energy (используйте наследование с помощью ключевого свойства extends), а также метод act() по которому:
растения растут - увеличивают свое energy на случайную величину от 0 до 1, если величина energy больше, например, 5 - растение размножается - появляется еще одно в случайном свободном месте доски и energy распределяется поровну. 
травоядные пасутся и едят растения: если в соседних клетках есть растение - травоядное выбирает то, у кого energy больше и перемещается на место растения и забирает себе его energy. если рядом нет растений - просто перемещается на 1 клетку в случайном направлении и расходуется энергия energy - например 0.5; если у травоядного энергия меньше 0.5 - оно не может двигаться и отдыхает, просто добавляет себе 0.2 к energy. Травоядные размножаются если энергия более 10 таким же способом как и растения.
Хищники едят травоядных - если в прямоугольнике в соседстве 2х клеток есть травоядное - хищник выбирает самое “жирное” и перемещается туда съедая его (прибавляя energy). если нет - просто бродит - перемещаясь на 1 пустую клетку в случайном направлении и расходуется энергия energy - например 0.5, если у хищника энергия меньше 0.5 или меньше - оно не может двигаться и отдыхает, просто добавляет себе 0.2 к energy. Хищники не размножаются.
У класса Word должен быть метод act. при котором осуществляется один шаг симуляции (вызываются act вначале у всех растений, потом у травоядных и затем у хищников). Распечатку состояния после каждого шага можно делать в виде текстового блока 50x50 где разные типы сущностей разные символы (@ растения, h - травоядное. C - хищник). Инициализируйте мир начальным количеством растений, травоядных и небольшим кол-вом хищников и проведите симуляцию в 10-20 шагов. Коэффициенты взяты мной случайно, попытайтесь изменить их чтобы мир “жил” (процесс самовоспроизводства растений шел непрерывно).

Создать “внутренности” простейшего текстового редактора с многоуровневой отменой. Программа должна содержать следующие классы. 
TextStorage со свойством text  в котором будет храниться редактируемый текст (добавьте методы логирования, когда происходит получение и изменение этого свойства). 
TextRange - с двумя полями position  и lenght - позиция и длина текста для манипуляции. 
TextOperation с полями TextRange и text. методом do. Метод do принимает TextStorage и делает следующее - удаляет текст в TextStorage.text начиная с TextRange.position и длиной TextRange.length и вставляет в эту же строку начиная с TextRange.position текст из TextOperation.text. и записывает модифицированную версию. Затем генерирует “обратную“ TextOperation (то есть такую вызвав do на которой можно привести текст к исходному состоянию) и возвращает ее. 
TextProcessor со свойством selection (TextRange) а также методами .delete() - удаляет текст, описанный в selection и обнуляет selection.length, replace(text) - заменят текст и обнуляет selection.length, enter(text) - используется только положение в selection и вставляет текст и обнуляет  selection.length. undo() - отменяет операции (по одной за раз). Методы delete\replace\enter создают соответвующие TextOperation и посылают их методу do(textOperation) который вызывает do у операции (передает TextStorage, получает результат и сохраняет в конце массива отмен. undo соответвенно извлекает из конца этого массива и выполняет операцию.
Напишите тесты для манипуляции текстом через TextProcessor. Если возможно, напишите операцию redo() для отмены undo.

Написать набор классов для простейшей электронной таблицы:
Класс Sheet собственно класс таблицы. Внутри есть список ячеек, Есть метод value(1, 2) который возвращает значение ячейки с координатами 1, 2. если ячейка пуста (не задана) возвращается 0. есть метод calc() который рассчитывает формулы в ячейках. Имейте в виду, что формулы могут циклически зависеть друг от друга. Для разрешения этой проблемы метод пробегает по всем заданным ячейкам и вызывает у них метод calc. Если хоть одна из них изменилась (Cell.calc вернул true) цикл повторяется. Если разрешить все ячейки таблицы не получилось за 10 итераций метод бросает исключение.
класс Cell который хранит информацию о ячейки. Координаты, а также в ней может быть число или формула. есть свойство Cell.value которое возвращает текущее значение в ячейке. формулы и значения передаются в виде строковых JavaScript выражений. Также в классе есть метод Cell.calc который производит вычисление переданной строки с помощью eval, сравнивает с вычисленным значением на предыдущем шаге (прошлый раз), обновляет свойство value и возвращает true если значение ячейки поменялось. На другие ячейки в тексте формулы можно ссылаться с помощью конструкции c(1, 2) - 1 и 2 координаты ячейки.
Напишите код для задания начальных  значений и формул и добавьте вывод рассчитанной таблицы любым удобным вам способом.
